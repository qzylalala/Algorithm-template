## 线段树



### 代码模板

```c++
#include <bits/stdc++.h>

typedef long long int ll;
using namespace std;

const int N = 100010;
ll A[N], tree[N * 4], mark[N * 4];

int n, m, p;


// -----------------------------------模板部分------------------------------------------
// 构建线段树
void build(ll l = 1, ll r = n, ll p = 1) {
	if (l == r) {
		tree[p] = A[l];
	}
	
	else {
		ll mid = l + r >> 1;
		build(l, mid, p * 2);
		build(mid + 1, r, p * 2 + 1);
		tree[p] = tree[p * 2] + tree[p * 2 + 1];
	}
}


// 更新 和 查询 都会用到的操作
void push_down(ll p, ll len) {
	mark[p * 2] += mark[p];
	mark[p * 2 + 1] += mark[p];
	tree[p * 2] += mark[p] * (len - len / 2);
	tree[p * 2 + 1] += mark[p] * (len / 2);
	mark[p] = 0;
}


// 更新操作
void update(ll l, ll r, ll d, ll p, ll cl, ll cr) {
	if (cl > r || cr < l) return ;
	else if (cl >= l && cr <= r) {
		tree[p] += (cr - cl + 1) * d;
		if (cr > cl) mark[p] += d;
	}
	else {
		ll mid = cl + cr >> 1;
		push_down(p, cr - cl + 1);
		update(l, r, d, p * 2, cl, mid);
		update(l, r, d, p * 2 + 1, mid + 1, cr);
		tree[p] = tree[p * 2] + tree[p * 2 + 1];
	}
} 


// 查询操作
ll query(ll l, ll r, ll p = 1, ll cl = 1, ll cr = n) {
	if (cl > r || cr < l) return 0;
	else if (cl >= l && cr <= r) return tree[p];
	else {
		ll mid = cl + cr >> 1;
		push_down(p, cr - cl + 1);
		return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr);
	}
}
//-------------------------------------模板部分------------------------------------------


int main () {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) scanf("%d", &A[i]);
	build();
	while (m --) {
		int op;
		scanf("%d", &op);
		if (op == 1) {
			int x, y, k;
			scanf("%d%d%d", &x, &y, &k);
			update(x, y, k, 1, 1, n);
		}
		else {
			int x, y;
			scanf("%d%d", &x, &y);
			printf("%lld\n", query(x, y));
		}
	}
	
	return 0;
} 
```

[可在此测试代码](https://www.luogu.com.cn/problem/P3372)

[线段树题单](https://www.luogu.com.cn/training/1124)

