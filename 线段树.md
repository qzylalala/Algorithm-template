## 线段树



### 代码模板

```c++
#include <bits/stdc++.h>

typedef long long int LL;
using namespace std;

const int N = 100010;
LL A[N], tree[N * 4], mark[N * 4];

int n, m, p;


// -----------------------------------模板部分------------------------------------------
// 构建线段树   自底向上
void build(LL l = 1, LL r = n, LL p = 1) {
	if (l == r) {
		tree[p] = A[l];
	}
	
	else {
		LL mid = l + r >> 1;
		build(l, mid, p * 2);						// 左
		build(mid + 1, r, p * 2 + 1);				// 右
		tree[p] = tree[p * 2] + tree[p * 2 + 1];	// 中
	}
}


// 更新 和 查询 都会用到的操作
void push_down(LL p, LL len) {
	mark[p * 2] += mark[p];
	mark[p * 2 + 1] += mark[p];
	tree[p * 2] += mark[p] * (len - len / 2);
	tree[p * 2 + 1] += mark[p] * (len / 2);
	mark[p] = 0;
}


// 更新操作
void update(LL l, LL r, LL d, LL p, LL cl, LL cr) {
    // 无交集
	if (cl > r || cr < l) return ;
	// 包含关系
    else if (cl >= l && cr <= r) {
		tree[p] += (cr - cl + 1) * d;
        // mark[p] += d  表示该区间上每一个点都要加上d
		if (cr > cl) mark[p] += d;		// 非叶子节点需要打标签, 叶子节点就不需要操作了
	}
    // 交叉关系
	else {
		LL mid = cl + cr >> 1;
		push_down(p, cr - cl + 1);
		update(l, r, d, p * 2, cl, mid);			// 左
		update(l, r, d, p * 2 + 1, mid + 1, cr);	// 右
		tree[p] = tree[p * 2] + tree[p * 2 + 1];	// 中
	}
} 


// 查询操作
LL query(LL l, LL r, LL p = 1, LL cl = 1, LL cr = n) {
	if (cl > r || cr < l) return 0;
	else if (cl >= l && cr <= r) return tree[p];
	else {
		LL mid = cl + cr >> 1;
		push_down(p, cr - cl + 1);
		return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr);
	}
}
//-------------------------------------模板部分------------------------------------------


int main () {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) scanf("%d", &A[i]);
	build();
	while (m --) {
		int op;
		scanf("%d", &op);
		if (op == 1) {
			int x, y, k;
			scanf("%d%d%d", &x, &y, &k);
			update(x, y, k, 1, 1, n);
		}
		else {
			int x, y;
			scanf("%d%d", &x, &y);
			printf("%LLd\n", query(x, y));
		}
	}
	
	return 0;
} 
```

[可在此测试代码](https://www.luogu.com.cn/problem/P3372)

[线段树题单](https://www.luogu.com.cn/training/1124)

